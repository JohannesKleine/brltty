#!/bin/bash
. /brltty/current/libexec/canute-prologue.sh
shopt -s extglob

addTestModeOption
addProgramOption A flag allActions "perform all of the actions - implies -p -P -f -F -k -l -u -s -b -r"
addProgramOption p flag requiredPackages "install required packages - implied by -A"
addProgramOption P flag unwantedPackages "remove unwanted packages - implied by -A"
addProgramOption f flag hostFiles "install host files - implied by -A"
addProgramOption F flag unwantedFiles "remove unwanted files - implied by -A"
addProgramOption k flag apiKey "generate BrlAPI access key - implied by -A"
addProgramOption l flag sharedLibraries "configure shared libraries - implied by -A"
addProgramOption u flag udevRules "reload Udev rules - implied by -A"
addProgramOption s flag systemdUnits "configure Systemd units - implied by -A"
addProgramOption b flag bootTaret "set boot target"
addProgramOption r flag rebootSystem "reboot system - implied by -A"
parseProgramArguments "${@}"

actionFlags=(requiredPackages unwantedPackages hostFiles unwantedFiles apiKey sharedLibraries udevRules systemdUnits bootTaret setupFinished rebootSystem)
setupFinished=false
verifyActionFlags allActions "${actionFlags[@]}"

readList() {
   local listArray="${1}"
   local name="${2}"

   local file="${installTree}/etc/${name}"
   verifyInputFile "${file}"

   local list=()
   local item

   while read item
   do
      item="${item##*( )}"
      [ -n "${item}" ] || continue
      [ "${item:0:1}" != "#" ] || continue
      item="${item%%*( )}"

      list+=("${item}")
   done <"${file}"

   [ "${#list[*]}" -gt 0 ] || return 1
   setElements "${listArray}" "${list[@]}"
   return 0
}

performAction_requiredPackages() {
   local -a packages

   ! readList packages required-packages || {
      logTask "updating package metadata"
      executeHostCommand apt --quiet --quiet --quiet -- update

      logTask "installing required packages"
      executeHostCommand apt --yes --quiet --quiet --quiet install -- "${packages[@]}"
   }
}

performAction_unwantedPackages() {
   local -a packages

   ! readList packages unwanted-packages || {
      logTask "removing unwanted packages"
      executeHostCommand apt --yes --quiet --quiet --quiet remove -- "${packages[@]}"
   }
}

performAction_hostFiles() {
   logTask "installing host files"
   executeHostCommand tar --extract --file "${installTree}/etc.tar" --directory "/"
}

performAction_unwantedFiles() {
   local -a files

   ! readList files unwanted-files || {
      logTask "removing unwanted files"
      local file

      for file in "${files[@]}"
      do
         [ -e "${file}" ] || continue

         if [ -d "${file}" ]
         then
            executeHostCommand rm -f -r -- "${file}"
         else
            executeHostCommand rm -f -- "${file}"
         fi
      done
   }
}

performAction_apiKey() {
   logTask "generating BrlAPI access key"

   local apiKeyFile="/etc/brlapi.key"
   executeHostCommand "${installTree}/bin/brltty-genkey" -q -f "${apiKeyFile}"
   executeHostCommand chmod u=rw,go=r "${apiKeyFile}"
}

performAction_sharedLibraries() {
   logTask "configuring shared libraries"
   local file lines=""

   while read file
   do
      [ -z "${lines}" ] || lines+=$'\n'
      lines+="${file}"
   done < <(find "${installTree}/" -type f \( -name "*.so" -o -name "*.so.*" \))

   sed <<<"${lines}" --regexp-extended --expression '
      s%/[^/]*$%%
      /\/brltty$/d
   ' | sort | uniq >"${ldConfigurationFile}"

   executeHostCommand ldconfig
}

performAction_udevRules() {
   logTask "reloading Udev rules"
   executeHostCommand udevadm control --reload
}

performAction_systemdUnits() {
   logTask "reloading Systemd units"
   executeHostCommand systemctl --quiet daemon-reload

   logTask "configuring Systemd units"
   local unit

   for unit in "${canuteSystemdUnit}"
   do
      ! systemctl --quiet is-active "${unit}" || executeHostCommand systemctl --quiet stop "${unit}"
      executeHostCommand systemctl --quiet start "${unit}"
      systemctl --quiet is-enabled "${unit}" || executeHostCommand systemctl --quiet enable "${unit}"
   done
}

performAction_bootTaret() {
   logTask "setting boot target"
   executeHostCommand systemctl --quiet set-default multi-user.target
}

performAction_setupFinished() {
   logTask "setup finished"
}

performAction_rebootSystem() {
   executeHostCommand sync

   if confirmAction "reboot system"
   then
      executeHostCommand reboot
   else
      logNotice "system not rebooted"
   fi
}

"${testMode}" || [ "$(id -u)" -eq 0 ] || semanticError "not executing as root"
set -e

for action in "${actionFlags[@]}"
do
   ! "${!action}" || {
      "performAction_${action}"
   }
done

exit 0
